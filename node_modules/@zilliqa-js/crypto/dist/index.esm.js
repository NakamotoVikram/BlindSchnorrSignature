import elliptic, { ec } from 'elliptic';
import hashjs from 'hash.js';
import DRBG from 'hmac-drbg';
import { BN, validation, bytes } from '@zilliqa-js/util';
import { __awaiter, __generator } from 'tslib';
import aes from 'aes-js';
import { pbkdf2Sync } from 'pbkdf2';
import scrypt from 'scrypt-js';
import { v4 } from 'uuid';

//  Copyright (C) 2018 Zilliqa
//
//  This file is part of Zilliqa-Javascript-Library.
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
/**
 * randomBytes
 *
 * Uses JS-native CSPRNG to generate a specified number of bytes.
 * NOTE: this method throws if no PRNG is available.
 *
 * @param {number} bytes
 * @returns {string}
 */
var randomBytes = function (bytes$$1) {
    var _a, _b;
    var b = Buffer.allocUnsafe(bytes$$1);
    var n = b.byteLength;
    var isBrowserEnv = typeof window !== 'undefined' && typeof window.document !== 'undefined';
    var isWebWorkerEnv = typeof self === 'object' &&
        ((_a = self.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'DedicatedWorkerGlobalScope';
    var isNodeEnv = typeof process !== 'undefined' &&
        typeof ((_b = process === null || process === void 0 ? void 0 : process.versions) === null || _b === void 0 ? void 0 : _b.node) === 'string';
    var crypto = undefined;
    if (isBrowserEnv || isWebWorkerEnv) {
        // web worker: self.crypto
        // browser: window.crypto
        // @ts-ignore
        crypto = global.crypto || global.msCrypto; // for IE 11
    }
    if (typeof (crypto === null || crypto === void 0 ? void 0 : crypto.getRandomValues) === 'function') {
        // For browser or web worker enviroment, use window.crypto.getRandomValues()
        // https://paragonie.com/blog/2016/05/how-generate-secure-random-numbers-in-various-programming-languages#js-csprng
        // limit of getRandomValues()
        // The requested length exceeds 65536 bytes.
        // https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues#exceptions
        var MAX_BYTES = 65536;
        for (var i = 0; i < n; i += MAX_BYTES) {
            // typedArray = crypto.getRandomValues(typedArray);
            // Note that typedArray is modified in-place, and no copy is made.
            crypto.getRandomValues(new Uint8Array(b.buffer, i + b.byteOffset, Math.min(n - i, MAX_BYTES)));
        }
    }
    else if (isNodeEnv) {
        // For node enviroment, use sodium-native because we prefer kernel CSPRNG.
        // References:
        // - https://paragonie.com/blog/2016/05/how-generate-secure-random-numbers-in-various-programming-languages#nodejs-csprng
        // - https://github.com/nodejs/node/issues/5798
        //
        // This logic should run only in node env. Otherwise, it will throw an error 'require is not defined'.
        //
        // Consider using createRequire when typescipt 4.5 is available.
        // https://devblogs.microsoft.com/typescript/announcing-typescript-4-5-beta
        // https://nodejs.org/api/module.html#modulecreaterequirefilename
        //
        // eslint-disable-next-line
        var sodium = require('sodium-native');
        sodium.randombytes_buf(b);
    }
    else {
        throw new Error('No secure random number generator available');
    }
    return b.toString('hex');
};

//  Copyright (C) 2018 Zilliqa
var secp256k1 = new ec('secp256k1');
var curve = secp256k1.curve;
var PRIVKEY_SIZE_BYTES = 32;
// Public key is a point (x, y) on the curve.
// Each coordinate requires 32 bytes.
// In its compressed form it suffices to store the x co-ordinate
// and the sign for y.
// Hence a total of 33 bytes.
var PUBKEY_COMPRESSED_SIZE_BYTES = 33;
// Personalization string used for HMAC-DRBG instantiation.
var ALG = Buffer.from('Schnorr+SHA256  ', 'ascii');
// The length in bytes of the string above.
var ALG_LEN = 16;
// The length in bytes of entropy inputs to HMAC-DRBG
var ENT_LEN = 32;
var HEX_ENC = 'hex';
/**
 * generatePrivateKey
 *
 * @returns {string} - the hex-encoded private key
 */
var generatePrivateKey$$1 = function () {
    return secp256k1
        .genKeyPair({
        entropy: randomBytes(secp256k1.curve.n.byteLength()),
        entropyEnc: HEX_ENC,
        pers: 'zilliqajs+secp256k1+SHA256',
    })
        .getPrivate()
        .toString(16, PRIVKEY_SIZE_BYTES * 2);
};
/**
 * Hash (r | M).
 * @param {Buffer} msg
 * @param {BN} r
 *
 * @returns {Buffer}
 */
var hash$$1 = function (q, pubkey, msg) {
    var sha256 = hashjs.sha256();
    var totalLength = PUBKEY_COMPRESSED_SIZE_BYTES * 2 + msg.byteLength; // 33 q + 33 pubkey + variable msgLen
    var Q = q.toArrayLike(Buffer, 'be', 33);
    var B = Buffer.allocUnsafe(totalLength);
    Q.copy(B, 0);
    pubkey.copy(B, 33);
    msg.copy(B, 66);
    return new BN(sha256.update(B).digest('hex'), 16);
};
/**
 * sign
 *
 * @param {Buffer} msg
 * @param {Buffer} key
 * @param {Buffer} pubkey
 *
 * @returns {Signature}
 */
var sign$$1 = function (msg, privKey, pubKey) {
    var prv = new BN(privKey);
    var drbg = getDRBG(msg);
    var len = curve.n.byteLength();
    var sig;
    while (!sig) {
        var k = new BN(drbg.generate(len));
        sig = trySign$$1(msg, k, prv, pubKey);
    }
    return sig;
};
/**
 * trySign
 *
 * @param {Buffer} msg - the message to sign over
 * @param {BN} k - output of the HMAC-DRBG
 * @param {BN} privateKey - the private key
 * @param {Buffer} pubKey - the public key
 *
 * @returns {Signature | null =>}
 */
var trySign$$1 = function (msg, k, privKey, pubKey) {
    if (privKey.isZero()) {
        throw new Error('Bad private key.');
    }
    if (privKey.gte(curve.n)) {
        throw new Error('Bad private key.');
    }
    // 1a. check that k is not 0
    if (k.isZero()) {
        return null;
    }
    // 1b. check that k is < the order of the group
    if (k.gte(curve.n)) {
        return null;
    }
    // 2. Compute commitment Q = kG, where g is the base point
    var Q = curve.g.mul(k);
    // convert the commitment to octets first
    var compressedQ = new BN(Q.encodeCompressed());
    // 3. Compute the challenge r = H(Q || pubKey || msg)
    // mod reduce the r value by the order of secp256k1, n
    var r = hash$$1(compressedQ, pubKey, msg).umod(curve.n);
    var h = r.clone();
    if (h.isZero()) {
        return null;
    }
    // 4. Compute s = k - r * prv
    // 4a. Compute r * prv
    var s = h.imul(privKey).umod(curve.n);
    // 4b. Compute s = k - r * prv mod n
    s = k.isub(s).umod(curve.n);
    if (s.isZero()) {
        return null;
    }
    return new Signature({ r: r, s: s });
};
/**
 * Verify signature.
 *
 * @param {Buffer} msg
 * @param {Buffer} signature
 * @param {Buffer} key
 *
 * @returns {boolean}
 *
 * 1. Check if r,s is in [1, ..., order-1]
 * 2. Compute Q = sG + r*kpub
 * 3. If Q = O (the neutral point), return 0;
 * 4. r' = H(Q, kpub, m)
 * 5. return r' == r
 */
var verify$$1 = function (msg, signature, key) {
    var sig = new Signature(signature);
    if (sig.s.isZero() || sig.r.isZero()) {
        throw new Error('Invalid signature');
    }
    if (sig.s.isNeg() || sig.r.isNeg()) {
        throw new Error('Invalid signature');
    }
    if (sig.s.gte(curve.n) || sig.r.gte(curve.n)) {
        throw new Error('Invalid signature');
    }
    var kpub = curve.decodePoint(key);
    if (!curve.validate(kpub)) {
        throw new Error('Invalid public key');
    }
    var l = kpub.mul(sig.r);
    var r = curve.g.mul(sig.s);
    var Q = l.add(r);
    if (Q.isInfinity()) {
        throw new Error('Invalid intermediate point.');
    }
    var compressedQ = new BN(Q.encodeCompressed());
    var r1 = hash$$1(compressedQ, key, msg).umod(curve.n);
    if (r1.isZero()) {
        throw new Error('Invalid hash.');
    }
    return r1.eq(sig.r);
};
var toSignature$$1 = function (serialised) {
    var r = serialised.slice(0, 64);
    var s = serialised.slice(64);
    return new Signature({ r: r, s: s });
};
/**
 * Instantiate an HMAC-DRBG.
 *
 * @param {Buffer} msg - used as nonce
 *
 * @returns {DRBG}
 */
var getDRBG = function (msg) {
    var entropy = randomBytes(ENT_LEN);
    var pers = Buffer.allocUnsafe(ALG_LEN + ENT_LEN);
    Buffer.from(randomBytes(ENT_LEN)).copy(pers, 0);
    ALG.copy(pers, ENT_LEN);
    return new DRBG({
        hash: hashjs.sha256,
        entropy: entropy,
        nonce: msg,
        pers: pers,
    });
};

var schnorr = /*#__PURE__*/Object.freeze({
  generatePrivateKey: generatePrivateKey$$1,
  hash: hash$$1,
  sign: sign$$1,
  trySign: trySign$$1,
  verify: verify$$1,
  toSignature: toSignature$$1
});

//  Copyright (C) 2018 Zilliqa
// This replaces `elliptic/lib/elliptic/ec/signature`.
// Q. Why do we replace `elliptic/lib/elliptic/ec/signature` with this?
// A. At the moment, Signature() in 'elliptic' is not exposed.
var Signature = /** @class */ (function () {
    function Signature(options) {
        var isValid = options.r && options.s;
        if (!isValid) {
            throw new Error('Signature without r or s');
        }
        this.r = new BN(options.r, 16);
        this.s = new BN(options.s, 16);
    }
    return Signature;
}());

//  Copyright (C) 2018 Zilliqa
// This code is taken from https://github.com/sipa/bech32/tree/bdc264f84014c234e908d72026b7b780122be11f/ref/javascript
// Copyright (c) 2017 Pieter Wuille
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
var CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
var GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
var polymod = function (values) {
    var chk = 1;
    for (var p = 0; p < values.length; ++p) {
        var top_1 = chk >> 25;
        chk = ((chk & 0x1ffffff) << 5) ^ values[p];
        for (var i = 0; i < 5; ++i) {
            if ((top_1 >> i) & 1) {
                chk ^= GENERATOR[i];
            }
        }
    }
    return chk;
};
var hrpExpand = function (hrp) {
    var ret = [];
    var p;
    for (p = 0; p < hrp.length; ++p) {
        ret.push(hrp.charCodeAt(p) >> 5);
    }
    ret.push(0);
    for (p = 0; p < hrp.length; ++p) {
        ret.push(hrp.charCodeAt(p) & 31);
    }
    return Buffer.from(ret);
};
function verifyChecksum(hrp, data) {
    return polymod(Buffer.concat([hrpExpand(hrp), data])) === 1;
}
function createChecksum(hrp, data) {
    var values = Buffer.concat([
        Buffer.from(hrpExpand(hrp)),
        data,
        Buffer.from([0, 0, 0, 0, 0, 0]),
    ]);
    // var values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);
    var mod = polymod(values) ^ 1;
    var ret = [];
    for (var p = 0; p < 6; ++p) {
        ret.push((mod >> (5 * (5 - p))) & 31);
    }
    return Buffer.from(ret);
}
var encode = function (hrp, data) {
    var combined = Buffer.concat([data, createChecksum(hrp, data)]);
    var ret = hrp + '1';
    for (var p = 0; p < combined.length; ++p) {
        ret += CHARSET.charAt(combined[p]);
    }
    return ret;
};
var decode = function (bechString) {
    var p;
    var hasLower = false;
    var hasUpper = false;
    for (p = 0; p < bechString.length; ++p) {
        if (bechString.charCodeAt(p) < 33 || bechString.charCodeAt(p) > 126) {
            return null;
        }
        if (bechString.charCodeAt(p) >= 97 && bechString.charCodeAt(p) <= 122) {
            hasLower = true;
        }
        if (bechString.charCodeAt(p) >= 65 && bechString.charCodeAt(p) <= 90) {
            hasUpper = true;
        }
    }
    if (hasLower && hasUpper) {
        return null;
    }
    bechString = bechString.toLowerCase();
    var pos = bechString.lastIndexOf('1');
    if (pos < 1 || pos + 7 > bechString.length || bechString.length > 90) {
        return null;
    }
    var hrp = bechString.substring(0, pos);
    var data = [];
    for (p = pos + 1; p < bechString.length; ++p) {
        var d = CHARSET.indexOf(bechString.charAt(p));
        if (d === -1) {
            return null;
        }
        data.push(d);
    }
    if (!verifyChecksum(hrp, Buffer.from(data))) {
        return null;
    }
    return { hrp: hrp, data: Buffer.from(data.slice(0, data.length - 6)) };
};
// HRP is the human-readable part of zilliqa bech32 addresses
var HRP = 'zil';
/**
 * convertBits
 *
 * groups buffers of a certain width to buffers of the desired width.
 *
 * For example, converts byte buffers to buffers of maximum 5 bit numbers,
 * padding those numbers as necessary. Necessary for encoding Ethereum-style
 * addresses as bech32 ones.
 *
 * @param {Buffer} data
 * @param {number} fromWidth
 * @param {number} toWidth
 * @param {boolean} pad
 * @returns {Buffer|null}
 */
var convertBits = function (data, fromWidth, toWidth, pad) {
    if (pad === void 0) { pad = true; }
    var acc = 0;
    var bits = 0;
    var ret = [];
    var maxv = (1 << toWidth) - 1;
    for (var p = 0; p < data.length; ++p) {
        var value = data[p];
        if (value < 0 || value >> fromWidth !== 0) {
            return null;
        }
        acc = (acc << fromWidth) | value;
        bits += fromWidth;
        while (bits >= toWidth) {
            bits -= toWidth;
            ret.push((acc >> bits) & maxv);
        }
    }
    if (pad) {
        if (bits > 0) {
            ret.push((acc << (toWidth - bits)) & maxv);
        }
    }
    else if (bits >= fromWidth || (acc << (toWidth - bits)) & maxv) {
        return null;
    }
    return Buffer.from(ret);
};
/**
 * toBech32Address
 *
 * Encodes a canonical 20-byte Ethereum-style address as a bech32 zilliqa
 * address.
 *
 * The expected format is zil1<address><checksum> where address and checksum
 * are the result of bech32 encoding a Buffer containing the address bytes.
 *
 * @param {string} 20 byte canonical address
 * @returns {string} 38 char bech32 encoded zilliqa address
 */
var toBech32Address = function (address) {
    if (!validation.isAddress(address)) {
        throw new Error('Invalid address format.');
    }
    var addrBz = convertBits(Buffer.from(address.replace('0x', ''), 'hex'), 8, 5);
    if (addrBz === null) {
        throw new Error('Could not convert byte Buffer to 5-bit Buffer');
    }
    return encode(HRP, addrBz);
};
/**
 * fromBech32Address
 *
 * @param {string} address - a valid Zilliqa bech32 address
 * @returns {string} a canonical 20-byte Ethereum-style address
 */
var fromBech32Address = function (address) {
    var res = decode(address);
    if (res === null) {
        throw new Error('Invalid bech32 address');
    }
    var hrp = res.hrp, data = res.data;
    var shouldBe = HRP;
    if (hrp !== shouldBe) {
        throw new Error("Expected hrp to be " + shouldBe + " but got " + hrp);
    }
    var buf = convertBits(data, 5, 8, false);
    if (buf === null) {
        throw new Error('Could not convert buffer to bytes');
    }
    return toChecksumAddress(buf.toString('hex'));
};

//  Copyright (C) 2018 Zilliqa
var secp256k1$1 = new elliptic.ec('secp256k1');
/**
 * getAddressFromPrivateKey
 *
 * takes a hex-encoded string (private key) and returns its corresponding
 * 20-byte hex-encoded address.
 *
 * @param {string} privateKey
 * @returns {string}
 */
var getAddressFromPrivateKey = function (privateKey) {
    var normalizedPrviateKey = normalizePrivateKey(privateKey);
    var keyPair = secp256k1$1.keyFromPrivate(normalizedPrviateKey, 'hex');
    var pub = keyPair.getPublic(true, 'hex');
    return toChecksumAddress(hashjs.sha256().update(pub, 'hex').digest('hex').slice(24));
};
/**
 * getPubKeyFromPrivateKey
 *
 * takes a hex-encoded string (private key) and returns its corresponding
 * hex-encoded 33-byte public key.
 *
 * @param {string} privateKey
 * @returns {string}
 */
var getPubKeyFromPrivateKey = function (privateKey) {
    var normalizedPrviateKey = normalizePrivateKey(privateKey);
    var keyPair = secp256k1$1.keyFromPrivate(normalizedPrviateKey, 'hex');
    return keyPair.getPublic(true, 'hex');
};
/**
 * getAccountFrom0xPrivateKey
 *
 * Utility method for recovering account from 0x private key.
 * See https://github.com/Zilliqa/Zilliqa-JavaScript-Library/pull/159
 * @param privateKeyWith0x : private key with 0x prefix
 */
var getAccountFrom0xPrivateKey = function (privateKeyWith0x) {
    var privateKeyWithout0x = normalizePrivateKey(privateKeyWith0x);
    var keyPair = secp256k1$1.keyFromPrivate(privateKeyWith0x, 'hex');
    var publicKeyWith0x = keyPair.getPublic(true, 'hex');
    var addressWith0x = getAddressFromPublicKey(publicKeyWith0x);
    var bech32With0x = toBech32Address(addressWith0x);
    var with0x = {
        prv: privateKeyWith0x,
        pub: publicKeyWith0x,
        addr: addressWith0x,
        bech32: bech32With0x,
    };
    var keyPair2 = secp256k1$1.keyFromPrivate(privateKeyWithout0x, 'hex');
    var publicKeyWithout0x = keyPair2.getPublic(true, 'hex');
    var addressWithout0x = getAddressFromPublicKey(publicKeyWithout0x);
    var bech32Without0x = toBech32Address(addressWithout0x);
    var without0x = {
        prv: privateKeyWithout0x,
        pub: publicKeyWithout0x,
        addr: addressWithout0x,
        bech32: bech32Without0x,
    };
    var privateKeyAfterChange = keyPair.getPrivate('hex');
    var publicKeyAfterChange = keyPair.getPublic(true, 'hex');
    var addressAfterChange = getAddressFromPublicKey(publicKeyAfterChange);
    var bech32AfterChange = toBech32Address(addressAfterChange);
    var changed = {
        prv: privateKeyAfterChange,
        pub: publicKeyAfterChange,
        addr: addressAfterChange,
        bech32: bech32AfterChange,
    };
    return {
        with0x: with0x,
        without0x: without0x,
        changed: changed,
    };
};
/**
 * compressPublicKey
 *
 * @param {string} publicKey - 65-byte public key, a point (x, y)
 *
 * @returns {string}
 */
var compressPublicKey = function (publicKey) {
    return secp256k1$1.keyFromPublic(publicKey, 'hex').getPublic(true, 'hex');
};
/**
 * getAddressFromPublicKey
 *
 * takes hex-encoded string and returns the corresponding address
 *
 * @param {string} pubKey
 * @returns {string}
 */
var getAddressFromPublicKey = function (publicKey) {
    var normalized = publicKey.toLowerCase().replace('0x', '');
    return toChecksumAddress(hashjs.sha256().update(normalized, 'hex').digest('hex').slice(24));
};
/**
 * toChecksumAddress
 *
 * takes hex-encoded string and returns the corresponding address
 *
 * @param {string} address
 * @returns {string}
 */
var toChecksumAddress = function (address) {
    if (!validation.isAddress(address)) {
        throw new Error(address + " is not a valid base 16 address");
    }
    address = address.toLowerCase().replace('0x', '');
    var hash = hashjs.sha256().update(address, 'hex').digest('hex');
    var v = new BN(hash, 'hex', 'be');
    var ret = '0x';
    for (var i = 0; i < address.length; i++) {
        if ('0123456789'.indexOf(address[i]) !== -1) {
            ret += address[i];
        }
        else {
            ret += v.and(new BN(2).pow(new BN(255 - 6 * i))).gte(new BN(1))
                ? address[i].toUpperCase()
                : address[i].toLowerCase();
        }
    }
    return ret;
};
/**
 * isValidChecksumAddress
 *
 * takes hex-encoded string and returns boolean if address is checksumed
 *
 * @param {string} address
 * @returns {boolean}
 */
var isValidChecksumAddress = function (address) {
    return (validation.isAddress(address.replace('0x', '')) &&
        toChecksumAddress(address) === address);
};
/**
 * normaliseAddress
 *
 * takes in a base16 address or a zilliqa bech32 encoded address
 * and returns a checksum base16 address. If the address is neither a base16
 * nor bech32 address, the code will return an error
 * @param {string)} address
 * @returns {string}
 */
var normaliseAddress = function (address) {
    if (validation.isBech32(address)) {
        return fromBech32Address(address);
    }
    if (!isValidChecksumAddress(address)) {
        throw Error('Wrong address format, should be either bech32 or checksummed address');
    }
    return address;
};
/**
 * encodeBase58 - may be required for DID public key
 * undeprecating this function after version 2.0.0
 *
 * @param {string} hex - base 16 encoded string
 * @returns {string} - big endian base 58 encoded string
 */
var encodeBase58 = function (hex) {
    var clean = hex.toLowerCase().replace('0x', '');
    var tbl = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    var base = new BN(58);
    var zero = new BN(0);
    var x = new BN(clean, 16);
    var res = '';
    while (x.gt(zero)) {
        var rem = x.mod(base).toNumber(); // safe, always < 58
        // big endian
        res = tbl[rem] + res;
        // quotient, remainders thrown away in integer division
        x = x.div(base);
    }
    // convert to big endian in case the input hex is little endian
    var hexBE = x.toString('hex', clean.length);
    for (var i = 0; i < hexBE.length; i += 2) {
        if (hex[i] === '0' && hex[i + 1] === '0') {
            res = tbl[0] + res;
        }
        else {
            break;
        }
    }
    return res;
};
/**
 * decodeBase58 - may be required for DID public key
 * undeprecating this function after version 2.0.0
 *
 * @param {string} raw - base 58 string
 * @returns {string} - big endian base 16 string
 */
var decodeBase58 = function (raw) {
    var tbl = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    var base = new BN(58);
    var zero = new BN(0);
    var isBreak = false;
    var n = new BN(0);
    var leader = '';
    for (var i = 0; i < raw.length; i++) {
        var char = raw.charAt(i);
        var weight = new BN(tbl.indexOf(char));
        n = n.mul(base).add(weight);
        // check if padding required
        if (!isBreak) {
            if (i - 1 > 0 && raw[i - 1] !== '1') {
                isBreak = true;
                continue;
            }
            if (char === '1') {
                leader += '00';
            }
        }
    }
    if (n.eq(zero)) {
        return leader;
    }
    var res = leader + n.toString('hex');
    if (res.length % 2 !== 0) {
        res = '0' + res;
    }
    return res;
};
/**
 * verifyPrivateKey
 *
 * @param {string|Buffer} privateKey
 * @returns {boolean}
 */
var verifyPrivateKey = function (privateKey) {
    var keyPair = secp256k1$1.keyFromPrivate(privateKey, 'hex');
    var result = keyPair.validate().result;
    return result;
};
/**
 * normalizePrivateKey : normalise private key from 0x or without 0x prefix
 *
 * @param {string} privateKey
 * @returns {string}
 */
var normalizePrivateKey = function (privateKey) {
    try {
        if (!validation.isPrivateKey(privateKey)) {
            throw new Error('Private key is not correct');
        }
        var normalized = privateKey.toLowerCase().replace('0x', '');
        if (!verifyPrivateKey(normalized)) {
            throw new Error('Private key is not correct');
        }
        return normalized;
    }
    catch (error) {
        throw error;
    }
};

//  Copyright (C) 2018 Zilliqa
var ALGO_IDENTIFIER = 'aes-128-ctr';
/**
 * getDerivedKey
 *
 * NOTE: only scrypt and pbkdf2 are supported.
 *
 * @param {Buffer} key - the passphrase
 * @param {KDF} kdf - the key derivation function to be used
 * @param {KDFParams} params - params for the kdf
 *
 * @returns {Promise<Buffer>}
 */
function getDerivedKey(key, kdf, params) {
    return __awaiter(this, void 0, void 0, function () {
        var salt, _a, c, dklen, _b, n, r, p, dklen, derivedKeyInt8Array;
        return __generator(this, function (_c) {
            salt = Buffer.from(params.salt, 'hex');
            if (kdf === 'pbkdf2') {
                _a = params, c = _a.c, dklen = _a.dklen;
                return [2 /*return*/, pbkdf2Sync(key, salt, c, dklen, 'sha256')];
            }
            if (kdf === 'scrypt') {
                _b = params, n = _b.n, r = _b.r, p = _b.p, dklen = _b.dklen;
                derivedKeyInt8Array = scrypt.syncScrypt(key, salt, n, r, p, dklen);
                return [2 /*return*/, Buffer.from(derivedKeyInt8Array)];
            }
            throw new Error('Only pbkdf2 and scrypt are supported');
        });
    });
}
/**
 * encryptPrivateKey
 *
 * Encodes and encrypts an account in the format specified by
 * https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition.
 * However, note that, in keeping with the hash function used by Zilliqa's
 * core protocol, the MAC is generated using sha256 instead of keccak.
 *
 * NOTE: only scrypt and pbkdf2 are supported.
 *
 * @param {KDF} kdf - the key derivation function to be used
 * @param {string} privateKey - hex-encoded private key
 * @param {string} passphrase - a passphrase used for encryption
 *
 * @returns {Promise<string>}
 */
var encryptPrivateKey = function (kdf, privateKey, passphrase) { return __awaiter(void 0, void 0, void 0, function () {
    var address, salt, iv, kdfparams, derivedKey, cipher, ciphertext;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                address = getAddressFromPrivateKey(privateKey);
                salt = randomBytes(32);
                iv = Buffer.from(randomBytes(16), 'hex');
                kdfparams = {
                    salt: salt,
                    n: 8192,
                    c: 262144,
                    r: 8,
                    p: 1,
                    dklen: 32,
                };
                return [4 /*yield*/, getDerivedKey(Buffer.from(passphrase), kdf, kdfparams)];
            case 1:
                derivedKey = _a.sent();
                cipher = new aes.ModeOfOperation.ctr(derivedKey.slice(0, 16), new aes.Counter(iv));
                ciphertext = Buffer.from(cipher.encrypt(Buffer.from(privateKey, 'hex')));
                return [2 /*return*/, JSON.stringify({
                        address: address,
                        crypto: {
                            cipher: ALGO_IDENTIFIER,
                            cipherparams: {
                                iv: iv.toString('hex'),
                            },
                            ciphertext: ciphertext.toString('hex'),
                            kdf: kdf,
                            kdfparams: kdfparams,
                            mac: hashjs
                                // @ts-ignore
                                .hmac(hashjs.sha256, derivedKey, 'hex')
                                .update(Buffer.concat([
                                derivedKey.slice(16, 32),
                                ciphertext,
                                iv,
                                Buffer.from(ALGO_IDENTIFIER),
                            ]), 'hex')
                                .digest('hex'),
                        },
                        id: v4({ random: bytes.hexToIntArray(randomBytes(16)) }),
                        version: 3,
                    })];
        }
    });
}); };
/**
 * decryptPrivateKey
 *
 * Recovers the private key from a keystore file using the given passphrase.
 *
 * @param {string} passphrase
 * @param {KeystoreV3} keystore
 * @returns {Promise<string>}
 */
var decryptPrivateKey = function (passphrase, keystore) { return __awaiter(void 0, void 0, void 0, function () {
    var ciphertext, iv, kdfparams, derivedKey, mac, cipher;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                ciphertext = Buffer.from(keystore.crypto.ciphertext, 'hex');
                iv = Buffer.from(keystore.crypto.cipherparams.iv, 'hex');
                kdfparams = keystore.crypto.kdfparams;
                return [4 /*yield*/, getDerivedKey(Buffer.from(passphrase), keystore.crypto.kdf, kdfparams)];
            case 1:
                derivedKey = _a.sent();
                mac = hashjs
                    // @ts-ignore
                    .hmac(hashjs.sha256, derivedKey, 'hex')
                    .update(Buffer.concat([
                    derivedKey.slice(16, 32),
                    ciphertext,
                    iv,
                    Buffer.from(ALGO_IDENTIFIER),
                ]), 'hex')
                    .digest('hex');
                // we need to do a byte-by-byte comparison to avoid non-constant time side
                // channel attacks.
                if (!bytes.isEqual(mac.toUpperCase(), keystore.crypto.mac.toUpperCase())) {
                    return [2 /*return*/, Promise.reject('Failed to decrypt.')];
                }
                cipher = new aes.ModeOfOperation.ctr(derivedKey.slice(0, 16), new aes.Counter(iv));
                return [2 /*return*/, Buffer.from(cipher.decrypt(ciphertext)).toString('hex')];
        }
    });
}); };

//  Copyright (C) 2018 Zilliqa

//  Copyright (C) 2018 Zilliqa
/**
 * sign
 *
 * @param {string} hash - hex-encoded hash of the data to be signed
 *
 * @returns {string} the signature
 */
var sign$1 = function (msg, privateKey, pubKey) {
    var sig = sign$$1(msg, Buffer.from(privateKey, 'hex'), Buffer.from(pubKey, 'hex'));
    var r = sig.r.toString('hex');
    var s = sig.s.toString('hex');
    while (r.length < 64) {
        r = '0' + r;
    }
    while (s.length < 64) {
        s = '0' + s;
    }
    return r + s;
};

export { sign$1 as sign, schnorr, Signature, getAddressFromPrivateKey, getPubKeyFromPrivateKey, getAccountFrom0xPrivateKey, compressPublicKey, getAddressFromPublicKey, toChecksumAddress, isValidChecksumAddress, normaliseAddress, encodeBase58, decodeBase58, verifyPrivateKey, normalizePrivateKey, encryptPrivateKey, decryptPrivateKey, randomBytes, encode, decode, HRP, convertBits, toBech32Address, fromBech32Address };
//# sourceMappingURL=index.esm.js.map
