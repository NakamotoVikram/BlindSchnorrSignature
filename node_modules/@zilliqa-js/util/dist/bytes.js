"use strict";
//  Copyright (C) 2018 Zilliqa
//
//  This file is part of Zilliqa-Javascript-Library.
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHex = exports.isEqual = exports.pack = exports.hexToIntArray = exports.hexToByteArray = exports.intToByteArray = exports.intToHexArray = void 0;
/**
 * intToHexArray
 *
 * @param {number} int - the number to be converted to hex
 * @param {number)} size - the desired width of the hex value. will pad.
 *
 * @returns {string[]}
 */
var intToHexArray = function (int, size) {
    var hex = [];
    var hexRep = [];
    var hexVal = int.toString(16);
    // TODO: this really needs to be refactored.
    for (var i = 0; i < hexVal.length; i++) {
        hexRep[i] = hexVal[i].toString();
    }
    for (var i = 0; i < size - hexVal.length; i++) {
        hex.push('0');
    }
    for (var i = 0; i < hexVal.length; i++) {
        hex.push(hexRep[i]);
    }
    return hex;
};
exports.intToHexArray = intToHexArray;
/**
 * intToByteArray
 *
 * Converts a number to Uint8Array
 *
 * @param {number} num
 * @param {number} size
 *
 * @returns {Uint8Array}
 */
var intToByteArray = function (num, size) {
    var x = num;
    var res = [];
    while (x > 0) {
        res.push(x & 255);
        x = x >> 8;
    }
    var pad = size - res.length;
    for (var i = 0; i < pad; i++) {
        res.unshift(0);
    }
    return Uint8Array.from(res);
};
exports.intToByteArray = intToByteArray;
/**
 * hexToByteArray
 *
 * Convers a hex string to a Uint8Array
 *
 * @param {string} hex
 * @returns {Uint8Array}
 */
var hexToByteArray = function (hex) {
    var res = new Uint8Array(hex.length / 2);
    for (var i = 0; i < hex.length; i += 2) {
        res[i / 2] = parseInt(hex.substring(i, i + 2), 16);
    }
    return res;
};
exports.hexToByteArray = hexToByteArray;
/**
 * hexToIntArray
 *
 * @param {string} hex
 * @returns {number[]}
 */
var hexToIntArray = function (hex) {
    if (!hex || !(0, exports.isHex)(hex)) {
        return [];
    }
    var res = [];
    for (var i = 0; i < hex.length; i++) {
        var c = hex.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        hi ? res.push(hi, lo) : res.push(lo);
    }
    return res;
};
exports.hexToIntArray = hexToIntArray;
/**
 * pack
 *
 * Takes two 16-bit integers and combines them. Used to compute version.
 *
 * @param {number} a
 * @param {number} b
 *
 * @returns {number} - a 32-bit number
 */
var pack = function (a, b) {
    if (a >> 16 > 0 || b >> 16 > 0) {
        throw new Error('Both a and b must be 16 bits or less');
    }
    return (a << 16) + b;
};
exports.pack = pack;
/**
 * compareBytes
 *
 * A constant time HMAC comparison function.
 *
 * @param {string} a
 * @param {string} b
 * @returns {boolean}
 */
var isEqual = function (a, b) {
    var bzA = (0, exports.hexToIntArray)(a);
    var bzB = (0, exports.hexToIntArray)(b);
    if (bzA.length !== bzB.length) {
        return false;
    }
    var result = 0;
    for (var i = 0; i < bzA.length; i++) {
        result |= bzA[i] ^ bzB[i];
    }
    return result === 0;
};
exports.isEqual = isEqual;
/**
 * isHex
 *
 * @param {string} str - string to be tested
 * @returns {boolean}
 */
var isHex = function (str) {
    var plain = str.replace('0x', '');
    return /[0-9a-f]*$/i.test(plain);
};
exports.isHex = isHex;
//# sourceMappingURL=bytes.js.map