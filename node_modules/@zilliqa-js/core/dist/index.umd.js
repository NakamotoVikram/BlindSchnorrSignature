(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('mitt')) :
  typeof define === 'function' && define.amd ? define(['exports', 'tslib', 'mitt'], factory) :
  (factory((global.zjsCore = {}),global.tslib,global.mitt));
}(this, (function (exports,tslib,mitt) { 'use strict';

  mitt = mitt && mitt.hasOwnProperty('default') ? mitt['default'] : mitt;

  //  Copyright (C) 2018 Zilliqa
  //
  //  This file is part of Zilliqa-Javascript-Library.
  //
  //  This program is free software: you can redistribute it and/or modify
  //  it under the terms of the GNU General Public License as published by
  //  the Free Software Foundation, either version 3 of the License, or
  //  (at your option) any later version.
  //
  //  This program is distributed in the hope that it will be useful,
  //  but WITHOUT ANY WARRANTY; without even the implied warranty of
  //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  //  GNU General Public License for more details.
  //
  //  You should have received a copy of the GNU General Public License
  //  along with this program.  If not, see <https://www.gnu.org/licenses/>.
  var Signer = /** @class */ (function () {
      function Signer() {
      }
      return Signer;
  }());
  (function (TransactionError) {
      TransactionError[TransactionError["CHECKER_FAILED"] = 0] = "CHECKER_FAILED";
      TransactionError[TransactionError["RUNNER_FAILED"] = 1] = "RUNNER_FAILED";
      TransactionError[TransactionError["BALANCE_TRANSFER_FAILED"] = 2] = "BALANCE_TRANSFER_FAILED";
      TransactionError[TransactionError["EXECUTE_CMD_FAILED"] = 3] = "EXECUTE_CMD_FAILED";
      TransactionError[TransactionError["EXECUTE_CMD_TIMEOUT"] = 4] = "EXECUTE_CMD_TIMEOUT";
      TransactionError[TransactionError["NO_GAS_REMAINING_FOUND"] = 5] = "NO_GAS_REMAINING_FOUND";
      TransactionError[TransactionError["NO_ACCEPTED_FOUND"] = 6] = "NO_ACCEPTED_FOUND";
      TransactionError[TransactionError["CALL_CONTRACT_FAILED"] = 7] = "CALL_CONTRACT_FAILED";
      TransactionError[TransactionError["CREATE_CONTRACT_FAILED"] = 8] = "CREATE_CONTRACT_FAILED";
      TransactionError[TransactionError["JSON_OUTPUT_CORRUPTED"] = 9] = "JSON_OUTPUT_CORRUPTED";
      TransactionError[TransactionError["CONTRACT_NOT_EXIST"] = 10] = "CONTRACT_NOT_EXIST";
      TransactionError[TransactionError["STATE_CORRUPTED"] = 11] = "STATE_CORRUPTED";
      TransactionError[TransactionError["LOG_ENTRY_INSTALL_FAILED"] = 12] = "LOG_ENTRY_INSTALL_FAILED";
      TransactionError[TransactionError["MESSAGE_CORRUPTED"] = 13] = "MESSAGE_CORRUPTED";
      TransactionError[TransactionError["RECEIPT_IS_NULL"] = 14] = "RECEIPT_IS_NULL";
      TransactionError[TransactionError["MAX_DEPTH_REACHED"] = 15] = "MAX_DEPTH_REACHED";
      TransactionError[TransactionError["CHAIN_CALL_DIFF_SHARD"] = 16] = "CHAIN_CALL_DIFF_SHARD";
      TransactionError[TransactionError["PREPARATION_FAILED"] = 17] = "PREPARATION_FAILED";
      TransactionError[TransactionError["NO_OUTPUT"] = 18] = "NO_OUTPUT";
      TransactionError[TransactionError["OUTPUT_ILLEGAL"] = 19] = "OUTPUT_ILLEGAL";
  })(exports.TransactionError || (exports.TransactionError = {}));

  //  Copyright (C) 2018 Zilliqa
  /**
   * sign
   *
   * This decorates a method by attempting to sign the first argument of the
   * intercepted method.
   *
   * @param {T} target
   * @param {K} key
   * @param {PropertyDescriptor} descriptor
   * @returns {PropertyDescriptor | undefined}
   */
  var sign = function (target, key, descriptor) {
      var original = descriptor.value;
      function interceptor(arg) {
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
              args[_i - 1] = arguments[_i];
          }
          return tslib.__awaiter(this, void 0, void 0, function () {
              var signed;
              return tslib.__generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          if (!(original && arg.bytes)) return [3 /*break*/, 2];
                          return [4 /*yield*/, this.signer.sign(arg)];
                      case 1:
                          signed = _a.sent();
                          return [2 /*return*/, original.call.apply(original, tslib.__spreadArray([this, signed], tslib.__read(args), false))];
                      case 2: return [2 /*return*/];
                  }
              });
          });
      }
      descriptor.value = interceptor;
      return descriptor;
  };

  //  Copyright (C) 2018 Zilliqa

  (function(self) {

    if (self.fetch) {
      return
    }

    var support = {
      searchParams: 'URLSearchParams' in self,
      iterable: 'Symbol' in self && 'iterator' in Symbol,
      blob: 'FileReader' in self && 'Blob' in self && (function() {
        try {
          new Blob();
          return true
        } catch(e) {
          return false
        }
      })(),
      formData: 'FormData' in self,
      arrayBuffer: 'ArrayBuffer' in self
    };

    if (support.arrayBuffer) {
      var viewClasses = [
        '[object Int8Array]',
        '[object Uint8Array]',
        '[object Uint8ClampedArray]',
        '[object Int16Array]',
        '[object Uint16Array]',
        '[object Int32Array]',
        '[object Uint32Array]',
        '[object Float32Array]',
        '[object Float64Array]'
      ];

      var isDataView = function(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj)
      };

      var isArrayBufferView = ArrayBuffer.isView || function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
    }

    function normalizeName(name) {
      if (typeof name !== 'string') {
        name = String(name);
      }
      if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
        throw new TypeError('Invalid character in header field name')
      }
      return name.toLowerCase()
    }

    function normalizeValue(value) {
      if (typeof value !== 'string') {
        value = String(value);
      }
      return value
    }

    // Build a destructive iterator for the value list
    function iteratorFor(items) {
      var iterator = {
        next: function() {
          var value = items.shift();
          return {done: value === undefined, value: value}
        }
      };

      if (support.iterable) {
        iterator[Symbol.iterator] = function() {
          return iterator
        };
      }

      return iterator
    }

    function Headers(headers) {
      this.map = {};

      if (headers instanceof Headers) {
        headers.forEach(function(value, name) {
          this.append(name, value);
        }, this);
      } else if (Array.isArray(headers)) {
        headers.forEach(function(header) {
          this.append(header[0], header[1]);
        }, this);
      } else if (headers) {
        Object.getOwnPropertyNames(headers).forEach(function(name) {
          this.append(name, headers[name]);
        }, this);
      }
    }

    Headers.prototype.append = function(name, value) {
      name = normalizeName(name);
      value = normalizeValue(value);
      var oldValue = this.map[name];
      this.map[name] = oldValue ? oldValue+','+value : value;
    };

    Headers.prototype['delete'] = function(name) {
      delete this.map[normalizeName(name)];
    };

    Headers.prototype.get = function(name) {
      name = normalizeName(name);
      return this.has(name) ? this.map[name] : null
    };

    Headers.prototype.has = function(name) {
      return this.map.hasOwnProperty(normalizeName(name))
    };

    Headers.prototype.set = function(name, value) {
      this.map[normalizeName(name)] = normalizeValue(value);
    };

    Headers.prototype.forEach = function(callback, thisArg) {
      for (var name in this.map) {
        if (this.map.hasOwnProperty(name)) {
          callback.call(thisArg, this.map[name], name, this);
        }
      }
    };

    Headers.prototype.keys = function() {
      var items = [];
      this.forEach(function(value, name) { items.push(name); });
      return iteratorFor(items)
    };

    Headers.prototype.values = function() {
      var items = [];
      this.forEach(function(value) { items.push(value); });
      return iteratorFor(items)
    };

    Headers.prototype.entries = function() {
      var items = [];
      this.forEach(function(value, name) { items.push([name, value]); });
      return iteratorFor(items)
    };

    if (support.iterable) {
      Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    }

    function consumed(body) {
      if (body.bodyUsed) {
        return Promise.reject(new TypeError('Already read'))
      }
      body.bodyUsed = true;
    }

    function fileReaderReady(reader) {
      return new Promise(function(resolve, reject) {
        reader.onload = function() {
          resolve(reader.result);
        };
        reader.onerror = function() {
          reject(reader.error);
        };
      })
    }

    function readBlobAsArrayBuffer(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsArrayBuffer(blob);
      return promise
    }

    function readBlobAsText(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsText(blob);
      return promise
    }

    function readArrayBufferAsText(buf) {
      var view = new Uint8Array(buf);
      var chars = new Array(view.length);

      for (var i = 0; i < view.length; i++) {
        chars[i] = String.fromCharCode(view[i]);
      }
      return chars.join('')
    }

    function bufferClone(buf) {
      if (buf.slice) {
        return buf.slice(0)
      } else {
        var view = new Uint8Array(buf.byteLength);
        view.set(new Uint8Array(buf));
        return view.buffer
      }
    }

    function Body() {
      this.bodyUsed = false;

      this._initBody = function(body) {
        this._bodyInit = body;
        if (!body) {
          this._bodyText = '';
        } else if (typeof body === 'string') {
          this._bodyText = body;
        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
          this._bodyBlob = body;
        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
          this._bodyFormData = body;
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this._bodyText = body.toString();
        } else if (support.arrayBuffer && support.blob && isDataView(body)) {
          this._bodyArrayBuffer = bufferClone(body.buffer);
          // IE 10-11 can't handle a DataView body.
          this._bodyInit = new Blob([this._bodyArrayBuffer]);
        } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
          this._bodyArrayBuffer = bufferClone(body);
        } else {
          throw new Error('unsupported BodyInit type')
        }

        if (!this.headers.get('content-type')) {
          if (typeof body === 'string') {
            this.headers.set('content-type', 'text/plain;charset=UTF-8');
          } else if (this._bodyBlob && this._bodyBlob.type) {
            this.headers.set('content-type', this._bodyBlob.type);
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
          }
        }
      };

      if (support.blob) {
        this.blob = function() {
          var rejected = consumed(this);
          if (rejected) {
            return rejected
          }

          if (this._bodyBlob) {
            return Promise.resolve(this._bodyBlob)
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(new Blob([this._bodyArrayBuffer]))
          } else if (this._bodyFormData) {
            throw new Error('could not read FormData body as blob')
          } else {
            return Promise.resolve(new Blob([this._bodyText]))
          }
        };

        this.arrayBuffer = function() {
          if (this._bodyArrayBuffer) {
            return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
          } else {
            return this.blob().then(readBlobAsArrayBuffer)
          }
        };
      }

      this.text = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text')
        } else {
          return Promise.resolve(this._bodyText)
        }
      };

      if (support.formData) {
        this.formData = function() {
          return this.text().then(decode)
        };
      }

      this.json = function() {
        return this.text().then(JSON.parse)
      };

      return this
    }

    // HTTP methods whose capitalization should be normalized
    var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

    function normalizeMethod(method) {
      var upcased = method.toUpperCase();
      return (methods.indexOf(upcased) > -1) ? upcased : method
    }

    function Request(input, options) {
      options = options || {};
      var body = options.body;

      if (input instanceof Request) {
        if (input.bodyUsed) {
          throw new TypeError('Already read')
        }
        this.url = input.url;
        this.credentials = input.credentials;
        if (!options.headers) {
          this.headers = new Headers(input.headers);
        }
        this.method = input.method;
        this.mode = input.mode;
        if (!body && input._bodyInit != null) {
          body = input._bodyInit;
          input.bodyUsed = true;
        }
      } else {
        this.url = String(input);
      }

      this.credentials = options.credentials || this.credentials || 'omit';
      if (options.headers || !this.headers) {
        this.headers = new Headers(options.headers);
      }
      this.method = normalizeMethod(options.method || this.method || 'GET');
      this.mode = options.mode || this.mode || null;
      this.referrer = null;

      if ((this.method === 'GET' || this.method === 'HEAD') && body) {
        throw new TypeError('Body not allowed for GET or HEAD requests')
      }
      this._initBody(body);
    }

    Request.prototype.clone = function() {
      return new Request(this, { body: this._bodyInit })
    };

    function decode(body) {
      var form = new FormData();
      body.trim().split('&').forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
      return form
    }

    function parseHeaders(rawHeaders) {
      var headers = new Headers();
      // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
      // https://tools.ietf.org/html/rfc7230#section-3.2
      var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
      preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
        var parts = line.split(':');
        var key = parts.shift().trim();
        if (key) {
          var value = parts.join(':').trim();
          headers.append(key, value);
        }
      });
      return headers
    }

    Body.call(Request.prototype);

    function Response(bodyInit, options) {
      if (!options) {
        options = {};
      }

      this.type = 'default';
      this.status = options.status === undefined ? 200 : options.status;
      this.ok = this.status >= 200 && this.status < 300;
      this.statusText = 'statusText' in options ? options.statusText : 'OK';
      this.headers = new Headers(options.headers);
      this.url = options.url || '';
      this._initBody(bodyInit);
    }

    Body.call(Response.prototype);

    Response.prototype.clone = function() {
      return new Response(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Headers(this.headers),
        url: this.url
      })
    };

    Response.error = function() {
      var response = new Response(null, {status: 0, statusText: ''});
      response.type = 'error';
      return response
    };

    var redirectStatuses = [301, 302, 303, 307, 308];

    Response.redirect = function(url, status) {
      if (redirectStatuses.indexOf(status) === -1) {
        throw new RangeError('Invalid status code')
      }

      return new Response(null, {status: status, headers: {location: url}})
    };

    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;

    self.fetch = function(input, init) {
      return new Promise(function(resolve, reject) {
        var request = new Request(input, init);
        var xhr = new XMLHttpRequest();

        xhr.onload = function() {
          var options = {
            status: xhr.status,
            statusText: xhr.statusText,
            headers: parseHeaders(xhr.getAllResponseHeaders() || '')
          };
          options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
          var body = 'response' in xhr ? xhr.response : xhr.responseText;
          resolve(new Response(body, options));
        };

        xhr.onerror = function() {
          reject(new TypeError('Network request failed'));
        };

        xhr.ontimeout = function() {
          reject(new TypeError('Network request failed'));
        };

        xhr.open(request.method, request.url, true);

        if (request.credentials === 'include') {
          xhr.withCredentials = true;
        } else if (request.credentials === 'omit') {
          xhr.withCredentials = false;
        }

        if ('responseType' in xhr && support.blob) {
          xhr.responseType = 'blob';
        }

        request.headers.forEach(function(value, name) {
          xhr.setRequestHeader(name, value);
        });

        xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
      })
    };
    self.fetch.polyfill = true;
  })(typeof self !== 'undefined' ? self : undefined);

  (function (RPCMethod) {
      // Network-related methods
      RPCMethod["GetNetworkId"] = "GetNetworkId";
      // Blockchain-related methods
      RPCMethod["GetBlockchainInfo"] = "GetBlockchainInfo";
      RPCMethod["GetShardingStructure"] = "GetShardingStructure";
      RPCMethod["GetDSBlock"] = "GetDsBlock";
      RPCMethod["GetLatestDSBlock"] = "GetLatestDsBlock";
      RPCMethod["GetNumDSBlocks"] = "GetNumDSBlocks";
      RPCMethod["GetDSBlockRate"] = "GetDSBlockRate";
      RPCMethod["DSBlockListing"] = "DSBlockListing";
      RPCMethod["GetTxBlock"] = "GetTxBlock";
      RPCMethod["GetLatestTxBlock"] = "GetLatestTxBlock";
      RPCMethod["GetNumTxBlocks"] = "GetNumTxBlocks";
      RPCMethod["GetTxBlockRate"] = "GetTxBlockRate";
      RPCMethod["TxBlockListing"] = "TxBlockListing";
      RPCMethod["GetNumTransactions"] = "GetNumTransactions";
      RPCMethod["GetTransactionRate"] = "GetTransactionRate";
      RPCMethod["GetCurrentMiniEpoch"] = "GetCurrentMiniEpoch";
      RPCMethod["GetCurrentDSEpoch"] = "GetCurrentDSEpoch";
      RPCMethod["GetPrevDifficulty"] = "GetPrevDifficulty";
      RPCMethod["GetPrevDSDifficulty"] = "GetPrevDSDifficulty";
      RPCMethod["GetTotalCoinSupply"] = "GetTotalCoinSupply";
      RPCMethod["GetMinerInfo"] = "GetMinerInfo";
      // Transaction-related methods
      RPCMethod["CreateTransaction"] = "CreateTransaction";
      RPCMethod["GetTransaction"] = "GetTransaction";
      RPCMethod["GetTransactionStatus"] = "GetTransactionStatus";
      RPCMethod["GetRecentTransactions"] = "GetRecentTransactions";
      RPCMethod["GetTransactionsForTxBlock"] = "GetTransactionsForTxBlock";
      RPCMethod["GetTransactionsForTxBlockEx"] = "GetTransactionsForTxBlockEx";
      RPCMethod["GetTxnBodiesForTxBlock"] = "GetTxnBodiesForTxBlock";
      RPCMethod["GetTxnBodiesForTxBlockEx"] = "GetTxnBodiesForTxBlockEx";
      RPCMethod["GetNumTxnsTxEpoch"] = "GetNumTxnsTxEpoch";
      RPCMethod["GetNumTxnsDSEpoch"] = "GetNumTxnsDSEpoch";
      RPCMethod["GetMinimumGasPrice"] = "GetMinimumGasPrice";
      // Contract-related methods
      RPCMethod["GetContractAddressFromTransactionID"] = "GetContractAddressFromTransactionID";
      RPCMethod["GetSmartContracts"] = "GetSmartContracts";
      RPCMethod["GetSmartContractCode"] = "GetSmartContractCode";
      RPCMethod["GetSmartContractInit"] = "GetSmartContractInit";
      RPCMethod["GetSmartContractState"] = "GetSmartContractState";
      RPCMethod["GetSmartContractSubState"] = "GetSmartContractSubState";
      RPCMethod["GetStateProof"] = "GetStateProof";
      // Account-related methods
      RPCMethod["GetBalance"] = "GetBalance";
  })(exports.RPCMethod || (exports.RPCMethod = {}));
  (function (RPCErrorCode) {
      // Standard JSON-RPC 2.0 errors
      // RPC_INVALID_REQUEST is internally mapped to HTTP_BAD_REQUEST (400).
      // It should not be used for application-layer errors.
      RPCErrorCode[RPCErrorCode["RPC_INVALID_REQUEST"] = -32600] = "RPC_INVALID_REQUEST";
      // RPC_METHOD_NOT_FOUND is internally mapped to HTTP_NOT_FOUND (404).
      // It should not be used for application-layer errors.
      RPCErrorCode[RPCErrorCode["RPC_METHOD_NOT_FOUND"] = -32601] = "RPC_METHOD_NOT_FOUND";
      RPCErrorCode[RPCErrorCode["RPC_INVALID_PARAMS"] = -32602] = "RPC_INVALID_PARAMS";
      // RPC_INTERNAL_ERROR should only be used for genuine errors in bitcoind
      // (for example datadir corruption).
      RPCErrorCode[RPCErrorCode["RPC_INTERNAL_ERROR"] = -32603] = "RPC_INTERNAL_ERROR";
      RPCErrorCode[RPCErrorCode["RPC_PARSE_ERROR"] = -32700] = "RPC_PARSE_ERROR";
      // General application defined errors
      RPCErrorCode[RPCErrorCode["RPC_MISC_ERROR"] = -1] = "RPC_MISC_ERROR";
      RPCErrorCode[RPCErrorCode["RPC_TYPE_ERROR"] = -3] = "RPC_TYPE_ERROR";
      RPCErrorCode[RPCErrorCode["RPC_INVALID_ADDRESS_OR_KEY"] = -5] = "RPC_INVALID_ADDRESS_OR_KEY";
      RPCErrorCode[RPCErrorCode["RPC_INVALID_PARAMETER"] = -8] = "RPC_INVALID_PARAMETER";
      RPCErrorCode[RPCErrorCode["RPC_DATABASE_ERROR"] = -20] = "RPC_DATABASE_ERROR";
      RPCErrorCode[RPCErrorCode["RPC_DESERIALIZATION_ERROR"] = -22] = "RPC_DESERIALIZATION_ERROR";
      RPCErrorCode[RPCErrorCode["RPC_VERIFY_ERROR"] = -25] = "RPC_VERIFY_ERROR";
      RPCErrorCode[RPCErrorCode["RPC_VERIFY_REJECTED"] = -26] = "RPC_VERIFY_REJECTED";
      RPCErrorCode[RPCErrorCode["RPC_IN_WARMUP"] = -28] = "RPC_IN_WARMUP";
      RPCErrorCode[RPCErrorCode["RPC_METHOD_DEPRECATED"] = -32] = "RPC_METHOD_DEPRECATED";
  })(exports.RPCErrorCode || (exports.RPCErrorCode = {}));
  var DEFAULT_HEADERS = { 'Content-Type': 'application/json' };
  var performRPC = function (request, handler) { return tslib.__awaiter(void 0, void 0, void 0, function () {
      var response, err_1;
      return tslib.__generator(this, function (_a) {
          switch (_a.label) {
              case 0:
                  _a.trys.push([0, 2, , 3]);
                  return [4 /*yield*/, fetch(request.url, {
                          method: 'POST',
                          cache: 'no-cache',
                          mode: 'cors',
                          redirect: 'follow',
                          referrer: 'no-referrer',
                          body: JSON.stringify(request.payload),
                          headers: tslib.__assign(tslib.__assign({}, DEFAULT_HEADERS), ((request.options && request.options.headers) || {})),
                      })];
              case 1:
                  response = _a.sent();
                  return [2 /*return*/, response
                          .json()
                          .then(function (body) {
                          return tslib.__assign(tslib.__assign({}, body), { req: request });
                      })
                          .then(handler)];
              case 2:
                  err_1 = _a.sent();
                  throw err_1;
              case 3: return [2 /*return*/];
          }
      });
  }); };
  // identical to performRPC; difference is the response
  var performBatchRPC = function (request, handler) { return tslib.__awaiter(void 0, void 0, void 0, function () {
      var response, err_2;
      return tslib.__generator(this, function (_a) {
          switch (_a.label) {
              case 0:
                  _a.trys.push([0, 2, , 3]);
                  return [4 /*yield*/, fetch(request.url, {
                          method: 'POST',
                          cache: 'no-cache',
                          mode: 'cors',
                          redirect: 'follow',
                          referrer: 'no-referrer',
                          body: JSON.stringify(request.payload),
                          headers: tslib.__assign(tslib.__assign({}, DEFAULT_HEADERS), ((request.options && request.options.headers) || {})),
                      })];
              case 1:
                  response = _a.sent();
                  return [2 /*return*/, (response
                          .json()
                          .then(function (batch_result) {
                          return { batch_result: batch_result, req: request };
                      })
                          // no handler as compared to performRPC to preserve the body array
                          // e.g. response
                          /*
                        { body:
                          [ { id: 1, jsonrpc: '2.0', result: [Object] },
                            { id: 1, jsonrpc: '2.0', result: [Object] } ],
                         req:
                          { url: 'https://dev-api.zilliqa.com',
                            payload: [ [Object], [Object] ] } }
                        */
                          .then())];
              case 2:
                  err_2 = _a.sent();
                  throw err_2;
              case 3: return [2 /*return*/];
          }
      });
  }); };

  //  Copyright (C) 2018 Zilliqa
  //
  //  This file is part of Zilliqa-Javascript-Library.
  //
  //  This program is free software: you can redistribute it and/or modify
  //  it under the terms of the GNU General Public License as published by
  //  the Free Software Foundation, either version 3 of the License, or
  //  (at your option) any later version.
  //
  //  This program is distributed in the hope that it will be useful,
  //  but WITHOUT ANY WARRANTY; without even the implied warranty of
  //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  //  GNU General Public License for more details.
  //
  //  You should have received a copy of the GNU General Public License
  //  along with this program.  If not, see <https://www.gnu.org/licenses/>.
  function isValidResponse(response) {
      if (response.jsonrpc === '2.0' &&
          (response.id === '1' || response.id === 1) &&
          (response.error || response.result)) {
          return true;
      }
      return false;
  }
  function composeMiddleware() {
      var fns = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          fns[_i] = arguments[_i];
      }
      if (fns.length === 0) {
          return function (arg) { return arg; };
      }
      if (fns.length === 1) {
          return fns[0];
      }
      return fns.reduce(function (a, b) { return function (arg) { return a(b(arg)); }; });
  }

  //  Copyright (C) 2018 Zilliqa
  var MiddlewareType;
  (function (MiddlewareType) {
      MiddlewareType[MiddlewareType["REQ"] = 0] = "REQ";
      MiddlewareType[MiddlewareType["RES"] = 1] = "RES";
  })(MiddlewareType || (MiddlewareType = {}));
  var BaseProvider = /** @class */ (function () {
      function BaseProvider(nodeURL, reqMiddleware, resMiddleware) {
          var _this = this;
          if (reqMiddleware === void 0) { reqMiddleware = new Map(); }
          if (resMiddleware === void 0) { resMiddleware = new Map(); }
          this.middleware = {
              request: {
                  use: function (fn, match) {
                      if (match === void 0) { match = '*'; }
                      _this.pushMiddleware(fn, 0 /* REQ */, match);
                  },
              },
              response: {
                  use: function (fn, match) {
                      if (match === void 0) { match = '*'; }
                      _this.pushMiddleware(fn, 1 /* RES */, match);
                  },
              },
          };
          this.nodeURL = nodeURL;
          this.reqMiddleware = reqMiddleware;
          this.resMiddleware = resMiddleware;
      }
      /**
       * pushMiddleware
       *
       * Adds the middleware to the appropriate middleware map.
       *
       * @param {ResMiddlewareFn}
       * @param {T} type
       * @param {Matcher} match
       * @returns {void}
       */
      BaseProvider.prototype.pushMiddleware = function (fn, type, match) {
          if (type !== 0 /* REQ */ && type !== 1 /* RES */) {
              throw new Error('Please specify the type of middleware being added');
          }
          if (type === 0 /* REQ */) {
              var current = this.reqMiddleware.get(match) || [];
              this.reqMiddleware.set(match, tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(current), false), [fn], false));
          }
          else {
              var current = this.resMiddleware.get(match) || [];
              this.resMiddleware.set(match, tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(current), false), [fn], false));
          }
      };
      /**
       * getMiddleware
       *
       * Returns the middleware that matches the matcher provided. Note that
       * middleware are called in order of specificity: string -> regexp ->
       * wildcard.
       *
       * @param {Matcher} match
       * @returns {[ReqMiddlewareFn[], ResMiddlewareFn[]]}
       */
      BaseProvider.prototype.getMiddleware = function (method) {
          var e_1, _a, e_2, _b;
          var reqFns = [];
          var resFns = [];
          try {
              for (var _c = tslib.__values(this.reqMiddleware.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
                  var _e = tslib.__read(_d.value, 2), key = _e[0], transformers = _e[1];
                  if (typeof key === 'string' && key !== '*' && key === method) {
                      reqFns.push.apply(reqFns, tslib.__spreadArray([], tslib.__read(transformers), false));
                  }
                  if (key instanceof RegExp && key.test(method)) {
                      reqFns.push.apply(reqFns, tslib.__spreadArray([], tslib.__read(transformers), false));
                  }
                  if (key === '*') {
                      reqFns.push.apply(reqFns, tslib.__spreadArray([], tslib.__read(transformers), false));
                  }
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
              }
              finally { if (e_1) throw e_1.error; }
          }
          try {
              for (var _f = tslib.__values(this.resMiddleware.entries()), _g = _f.next(); !_g.done; _g = _f.next()) {
                  var _h = tslib.__read(_g.value, 2), key = _h[0], transformers = _h[1];
                  if (typeof key === 'string' && key !== '*' && key === method) {
                      resFns.push.apply(resFns, tslib.__spreadArray([], tslib.__read(transformers), false));
                  }
                  if (key instanceof RegExp && key.test(method)) {
                      resFns.push.apply(resFns, tslib.__spreadArray([], tslib.__read(transformers), false));
                  }
                  if (key === '*') {
                      resFns.push.apply(resFns, tslib.__spreadArray([], tslib.__read(transformers), false));
                  }
              }
          }
          catch (e_2_1) { e_2 = { error: e_2_1 }; }
          finally {
              try {
                  if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
              }
              finally { if (e_2) throw e_2.error; }
          }
          return [reqFns, resFns];
      };
      return BaseProvider;
  }());

  //  Copyright (C) 2018 Zilliqa
  var HTTPProvider = /** @class */ (function (_super) {
      tslib.__extends(HTTPProvider, _super);
      function HTTPProvider() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      HTTPProvider.prototype.buildPayload = function (method, params) {
          return {
              url: this.nodeURL,
              payload: { id: 1, jsonrpc: '2.0', method: method, params: params },
          };
      };
      HTTPProvider.prototype.buildBatchPayload = function (method, paramsList) {
          var payloads = [];
          for (var i = 0; i < paramsList.length; i++) {
              // most of the payloads should be a single param, e.g. GetTransaction
              // however, there are special cases e.g. GetSmartContractSubState & GetTransactionsForTxBlockEx
              // where the param field is a list
              var payloadParams = paramsList[i];
              var params = void 0;
              if (Array.isArray(payloadParams)) {
                  // for those param field that is already a list
                  params = payloadParams;
              }
              else {
                  params = [payloadParams];
              }
              // id start from index 1
              payloads.push({
                  id: i + 1,
                  jsonrpc: '2.0',
                  method: method,
                  params: params,
              });
          }
          return {
              url: this.nodeURL,
              payload: payloads,
          };
      };
      HTTPProvider.prototype.send = function (method) {
          var params = [];
          for (var _i = 1; _i < arguments.length; _i++) {
              params[_i - 1] = arguments[_i];
          }
          var _a = tslib.__read(this.getMiddleware(method), 2), tReq = _a[0], tRes = _a[1];
          var reqMiddleware = composeMiddleware.apply(void 0, tslib.__spreadArray([], tslib.__read(tReq), false));
          var resMiddleware = composeMiddleware.apply(void 0, tslib.__spreadArray([], tslib.__read(tRes), false));
          var req = reqMiddleware(this.buildPayload(method, params));
          return performRPC(req, resMiddleware);
      };
      HTTPProvider.prototype.sendBatch = function (method, params) {
          var _a = tslib.__read(this.getMiddleware(method), 2), tReq = _a[0], tRes = _a[1];
          var reqMiddleware = composeMiddleware.apply(void 0, tslib.__spreadArray([], tslib.__read(tReq), false));
          var resMiddleware = composeMiddleware.apply(void 0, tslib.__spreadArray([], tslib.__read(tRes), false));
          var batchPayload = this.buildBatchPayload(method, params);
          var req = reqMiddleware(batchPayload);
          return performBatchRPC(req, resMiddleware);
      };
      HTTPProvider.prototype.subscribe = function (event, subscriber) {
          throw new Error('HTTPProvider does not support subscriptions.');
      };
      HTTPProvider.prototype.unsubscribe = function (token) {
          throw new Error('HTTPProvider does not support subscriptions.');
      };
      return HTTPProvider;
  }(BaseProvider));

  //  Copyright (C) 2018 Zilliqa
  //
  //  This file is part of Zilliqa-Javascript-Library.
  //
  //  This program is free software: you can redistribute it and/or modify
  //  it under the terms of the GNU General Public License as published by
  //  the Free Software Foundation, either version 3 of the License, or
  //  (at your option) any later version.
  //
  //  This program is distributed in the hope that it will be useful,
  //  but WITHOUT ANY WARRANTY; without even the implied warranty of
  //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  //  GNU General Public License for more details.
  //
  //  You should have received a copy of the GNU General Public License
  //  along with this program.  If not, see <https://www.gnu.org/licenses/>.
  // this constant is used to indicate the number of times to poll the
  // blockchain for a transaction confirmation. this number has been selected by
  // using a heuristic to calculate the approximate maximum amount of time it
  // should take for a transaction to be confirmed, even during a PoW submission
  // round.
  var GET_TX_ATTEMPTS = 33;

  //  Copyright (C) 2018 Zilliqa
  var EventEmitter = /** @class */ (function () {
      function EventEmitter() {
          var _this = this;
          this.handlers = {};
          this.emitter = new mitt(this.handlers);
          this.off = this.emitter.off.bind(this);
          this.emit = this.emitter.emit.bind(this);
          this.promise = new Promise(function (resolve, reject) {
              _this.resolve = resolve;
              _this.reject = reject;
          });
          this.then = this.promise.then.bind(this.promise);
      }
      EventEmitter.prototype.resetHandlers = function () {
          for (var i in this.handlers) {
              delete this.handlers[i];
          }
      };
      EventEmitter.prototype.on = function (type, handler) {
          this.emitter.on(type, handler);
          return this;
      };
      EventEmitter.prototype.once = function (type, handler) {
          var _this = this;
          this.emitter.on(type, function (e) {
              handler(e);
              _this.removeEventListener(type);
          });
      };
      EventEmitter.prototype.addEventListener = function (type, handler) {
          this.emitter.on(type, handler);
      };
      EventEmitter.prototype.removeEventListener = function (type, handler) {
          if (!type) {
              this.handlers = {};
              return;
          }
          if (!handler) {
              delete this.handlers[type];
          }
          else {
              return this.emitter.off(type, handler);
          }
      };
      EventEmitter.prototype.onError = function (error) {
          this.emitter.on('error', error);
          this.removeEventListener('*');
      };
      EventEmitter.prototype.onData = function (data) {
          this.emitter.on('data', data);
          this.removeEventListener('*');
      };
      EventEmitter.prototype.listenerCount = function (listenKey) {
          var count = 0;
          Object.keys(this.handlers).forEach(function (val) {
              if (listenKey === val) {
                  count += 1;
              }
          });
          return count;
      };
      return EventEmitter;
  }());

  //  Copyright (C) 2018 Zilliqa

  exports.Signer = Signer;
  exports.sign = sign;
  exports.performRPC = performRPC;
  exports.performBatchRPC = performBatchRPC;
  exports.isValidResponse = isValidResponse;
  exports.composeMiddleware = composeMiddleware;
  exports.HTTPProvider = HTTPProvider;
  exports.GET_TX_ATTEMPTS = GET_TX_ATTEMPTS;
  exports.EventEmitter = EventEmitter;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
